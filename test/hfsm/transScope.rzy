component
  TransScope
    input
      in();
      
    output
      outA();
      outB();
    
  implementation hfsm( A )
    var
      a : R{0,0};     // this variable is never read since A.a and B.b shadows it
      
    entry
      a := 0;
    end
  
    transition
      A to B by in() if a = 0;   // guard is evaluated in the scope of the source state
      B to A by in() if a = 0;
  
    state A
      var
        a : R{0,4};
        
      entry
        a := 4;
        outA();
      end
      
      transition
        A to A by in() if a > 0 do
          a := R{0,4}( a - 1 );
        end
    end
      
    state B
      entry
        a := 2;
        outB();
      end
      
      var
        a : R{0,2};
        
      transition
        B to B by in() if a > 0 do
          a := R{0,2}( a - 1 );
        end
    end

  end

