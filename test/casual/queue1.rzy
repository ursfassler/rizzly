Msg1 = Record
  dummy: R{0,0};
end

Msg2 = Record
  x: R{0,10};
  y: R{0,10};
end

Msg3 = Record
  x: R{-1000,1000};
end

Msg4 = Record
  x: Boolean;
end

Msg = Union
  msg1: Msg1;
  msg2: Msg2;
  msg3: Msg3;
  msg4: Msg4;
end

Size : const = 10;

Queue1 = Elementary
  outMsg1 : signal();
  outMsg2 : signal( x: R{0,10}; y: R{0,10} );
  outMsg3 : signal( x: R{-1000,1000} );
  outMsg4 : signal( x: Boolean );

  queue : Array{Size,Msg} = [ _ := (msg3 := ( 0 )) ];
  head  : R{0,Size-1} = 0;
  size  : R{0,Size} = 0;
    
  dispatch : slot()
    if size > 0 then
      case queue[head] of
        Msg.msg1: outMsg1(); end
        Msg.msg2: outMsg2( queue[head].msg2.x, queue[head].msg2.y ); end
        Msg.msg3: outMsg3( queue[head].msg3.x ); end
        Msg.msg4: outMsg4( queue[head].msg4.x ); end
      end
      head := (head + 1) mod Size;
      size := R{0,Size}(size - 1);
    end
  end
  
  count : response():R{0,Size}
    return size;
  end
    
  inMsg1 : slot()
    queue[head+size].msg1.dummy := 0;
    size := R{0,Size}(size + 1);
  end
  
  inMsg2 : slot( x: R{0,10}; y: R{0,10} )
    queue[head+size].msg2.x := x;
    queue[head+size].msg2.y := y;
    size := R{0,Size}(size + 1);
  end
  
  inMsg3 : slot( x: R{-1000,1000} )
    queue[head+size].msg3.x := x;
    size := R{0,Size}(size + 1);
  end
  
  inMsg4 : slot( x: Boolean )
    queue[head+size].msg4.x := x;
    size := R{0,Size}(size + 1);
  end

end

